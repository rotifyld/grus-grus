-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParGrusGrus where
import AbsGrusGrus
import LexGrusGrus
import ErrM

}

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%name pBody_internal Body
%token
  '!=' { PT _ (TS _ 1) }
  '%' { PT _ (TS _ 2) }
  '&&' { PT _ (TS _ 3) }
  '(' { PT _ (TS _ 4) }
  ')' { PT _ (TS _ 5) }
  '*' { PT _ (TS _ 6) }
  '+' { PT _ (TS _ 7) }
  ',' { PT _ (TS _ 8) }
  '-' { PT _ (TS _ 9) }
  '->' { PT _ (TS _ 10) }
  '/' { PT _ (TS _ 11) }
  ':' { PT _ (TS _ 12) }
  ';' { PT _ (TS _ 13) }
  '<' { PT _ (TS _ 14) }
  '<=' { PT _ (TS _ 15) }
  '=' { PT _ (TS _ 16) }
  '==' { PT _ (TS _ 17) }
  '>' { PT _ (TS _ 18) }
  '>=' { PT _ (TS _ 19) }
  'Bool' { PT _ (TS _ 20) }
  'False' { PT _ (TS _ 21) }
  'Int' { PT _ (TS _ 22) }
  'True' { PT _ (TS _ 23) }
  'Unit' { PT _ (TS _ 24) }
  '\\' { PT _ (TS _ 25) }
  'alg' { PT _ (TS _ 26) }
  'case' { PT _ (TS _ 27) }
  'else' { PT _ (TS _ 28) }
  'fun' { PT _ (TS _ 29) }
  'if' { PT _ (TS _ 30) }
  'of' { PT _ (TS _ 31) }
  'put' { PT _ (TS _ 32) }
  'then' { PT _ (TS _ 33) }
  'val' { PT _ (TS _ 34) }
  '{' { PT _ (TS _ 35) }
  '|' { PT _ (TS _ 36) }
  '||' { PT _ (TS _ 37) }
  '}' { PT _ (TS _ 38) }
  '~>' { PT _ (TS _ 39) }

  L_integ {PT _ (TI _)}
  L_LIdent {PT _ (T_LIdent _)}
  L_UIdent {PT _ (T_UIdent _)}

%%

Integer :: {
  (Maybe (Int, Int), Integer)
}
: L_integ {
  (Just (tokenLineCol $1), read (prToken $1)) 
}

LIdent :: {
  (Maybe (Int, Int), LIdent)
}
: L_LIdent {
  (Just (tokenLineCol $1), LIdent (prToken $1)) 
}

UIdent :: {
  (Maybe (Int, Int), UIdent)
}
: L_UIdent {
  (Just (tokenLineCol $1), UIdent (prToken $1)) 
}

Body :: {
  (Maybe (Int, Int), Body (Maybe (Int, Int)))
}
: ListDecl Exp {
  (fst $1, AbsGrusGrus.Body (fst $1)(reverse (snd $1)) (snd $2)) 
}

ListDecl :: {
  (Maybe (Int, Int), [Decl (Maybe (Int, Int))]) 
}
: {
  (Nothing, [])
}
| ListDecl Decl {
  (fst $1, flip (:) (snd $1)(snd $2)) 
}

Decl :: {
  (Maybe (Int, Int), Decl (Maybe (Int, Int)))
}
: 'put' Exp ';' {
  (Just (tokenLineCol $1), AbsGrusGrus.DPut (Just (tokenLineCol $1)) (snd $2)) 
}
| 'val' TypedIdent '=' Exp ';' {
  (Just (tokenLineCol $1), AbsGrusGrus.DVal (Just (tokenLineCol $1)) (snd $2)(snd $4)) 
}
| 'fun' LIdent '(' ListTypedIdent ')' '->' ParserType '{' Body '}' {
  (Just (tokenLineCol $1), AbsGrusGrus.DFun (Just (tokenLineCol $1)) (snd $2)(snd $4)(snd $7)(snd $9)) 
}
| 'alg' UIdent '=' ListTypeAlgConstr ';' {
  (Just (tokenLineCol $1), AbsGrusGrus.DAlg (Just (tokenLineCol $1)) (snd $2)(snd $4)) 
}

TypedIdent :: {
  (Maybe (Int, Int), TypedIdent (Maybe (Int, Int)))
}
: LIdent ':' ParserType {
  (fst $1, AbsGrusGrus.TypedIdent (fst $1)(snd $1)(snd $3)) 
}

ListTypedIdent :: {
  (Maybe (Int, Int), [TypedIdent (Maybe (Int, Int))]) 
}
: {
  (Nothing, [])
}
| TypedIdent {
  (fst $1, (:[]) (snd $1)) 
}
| TypedIdent ',' ListTypedIdent {
  (fst $1, (:) (snd $1)(snd $3)) 
}

ListTypeAlgConstr :: {
  (Maybe (Int, Int), [TypeAlgConstr (Maybe (Int, Int))]) 
}
: {
  (Nothing, [])
}
| TypeAlgConstr {
  (fst $1, (:[]) (snd $1)) 
}
| TypeAlgConstr '|' ListTypeAlgConstr {
  (fst $1, (:) (snd $1)(snd $3)) 
}

Exp :: {
  (Maybe (Int, Int), Exp (Maybe (Int, Int)))
}
: 'if' Exp 'then' Exp 'else' Exp {
  (Just (tokenLineCol $1), AbsGrusGrus.EIfte (Just (tokenLineCol $1)) (snd $2)(snd $4)(snd $6)) 
}
| 'case' Exp 'of' '{' ListCase '}' {
  (Just (tokenLineCol $1), AbsGrusGrus.ECase (Just (tokenLineCol $1)) (snd $2)(snd $5)) 
}
| Exp1 {
  (fst $1, snd $1)
}

Exp2 :: {
  (Maybe (Int, Int), Exp (Maybe (Int, Int)))
}
: Exp2 '||' Exp3 {
  (fst $1, AbsGrusGrus.EOr (fst $1)(snd $1)(snd $3)) 
}
| Exp3 {
  (fst $1, snd $1)
}

Exp3 :: {
  (Maybe (Int, Int), Exp (Maybe (Int, Int)))
}
: Exp3 '&&' Exp4 {
  (fst $1, AbsGrusGrus.EAnd (fst $1)(snd $1)(snd $3)) 
}
| Exp4 {
  (fst $1, snd $1)
}

Exp4 :: {
  (Maybe (Int, Int), Exp (Maybe (Int, Int)))
}
: Exp4 '==' Exp5 {
  (fst $1, AbsGrusGrus.EEq (fst $1)(snd $1)(snd $3)) 
}
| Exp4 '!=' Exp5 {
  (fst $1, AbsGrusGrus.ENeq (fst $1)(snd $1)(snd $3)) 
}
| Exp5 {
  (fst $1, snd $1)
}

Exp5 :: {
  (Maybe (Int, Int), Exp (Maybe (Int, Int)))
}
: Exp5 '<' Exp6 {
  (fst $1, AbsGrusGrus.ELt (fst $1)(snd $1)(snd $3)) 
}
| Exp5 '>' Exp6 {
  (fst $1, AbsGrusGrus.EGt (fst $1)(snd $1)(snd $3)) 
}
| Exp5 '<=' Exp6 {
  (fst $1, AbsGrusGrus.ELe (fst $1)(snd $1)(snd $3)) 
}
| Exp5 '>=' Exp6 {
  (fst $1, AbsGrusGrus.EGe (fst $1)(snd $1)(snd $3)) 
}
| Exp6 {
  (fst $1, snd $1)
}

Exp6 :: {
  (Maybe (Int, Int), Exp (Maybe (Int, Int)))
}
: Exp6 '+' Exp7 {
  (fst $1, AbsGrusGrus.EAdd (fst $1)(snd $1)(snd $3)) 
}
| Exp6 '-' Exp7 {
  (fst $1, AbsGrusGrus.ESub (fst $1)(snd $1)(snd $3)) 
}
| Exp7 {
  (fst $1, snd $1)
}

Exp7 :: {
  (Maybe (Int, Int), Exp (Maybe (Int, Int)))
}
: Exp7 '*' Exp8 {
  (fst $1, AbsGrusGrus.EMult (fst $1)(snd $1)(snd $3)) 
}
| Exp7 '/' Exp8 {
  (fst $1, AbsGrusGrus.EDiv (fst $1)(snd $1)(snd $3)) 
}
| Exp7 '%' Exp8 {
  (fst $1, AbsGrusGrus.EMod (fst $1)(snd $1)(snd $3)) 
}
| Exp8 {
  (fst $1, snd $1)
}

Exp8 :: {
  (Maybe (Int, Int), Exp (Maybe (Int, Int)))
}
: Exp8 '(' ListExp ')' {
  (fst $1, AbsGrusGrus.ECall (fst $1)(snd $1)(snd $3)) 
}
| Exp9 {
  (fst $1, snd $1)
}

Exp9 :: {
  (Maybe (Int, Int), Exp (Maybe (Int, Int)))
}
: '(' '\\' ListTypedIdent '~>' Body ')' {
  (Just (tokenLineCol $1), AbsGrusGrus.ELambda (Just (tokenLineCol $1)) (snd $3)(snd $5)) 
}
| Integer {
  (fst $1, AbsGrusGrus.EInt (fst $1)(snd $1)) 
}
| Boolean {
  (fst $1, AbsGrusGrus.EBool (fst $1)(snd $1)) 
}
| Unit {
  (fst $1, AbsGrusGrus.EUnit (fst $1)(snd $1)) 
}
| LIdent {
  (fst $1, AbsGrusGrus.EVar (fst $1)(snd $1)) 
}
| UIdent {
  (fst $1, AbsGrusGrus.EAlg (fst $1)(snd $1)) 
}
| '(' Exp ')' {
  (Just (tokenLineCol $1), snd $2)
}

ListExp :: {
  (Maybe (Int, Int), [Exp (Maybe (Int, Int))]) 
}
: {
  (Nothing, [])
}
| Exp {
  (fst $1, (:[]) (snd $1)) 
}
| Exp ',' ListExp {
  (fst $1, (:) (snd $1)(snd $3)) 
}

Exp1 :: {
  (Maybe (Int, Int), Exp (Maybe (Int, Int)))
}
: Exp2 {
  (fst $1, snd $1)
}

Case :: {
  (Maybe (Int, Int), Case (Maybe (Int, Int)))
}
: Exp '~>' Exp {
  (fst $1, AbsGrusGrus.Case (fst $1)(snd $1)(snd $3)) 
}

ListCase :: {
  (Maybe (Int, Int), [Case (Maybe (Int, Int))]) 
}
: {
  (Nothing, [])
}
| Case {
  (fst $1, (:[]) (snd $1)) 
}
| Case ';' ListCase {
  (fst $1, (:) (snd $1)(snd $3)) 
}

Boolean :: {
  (Maybe (Int, Int), Boolean (Maybe (Int, Int)))
}
: 'True' {
  (Just (tokenLineCol $1), AbsGrusGrus.BTrue (Just (tokenLineCol $1)))
}
| 'False' {
  (Just (tokenLineCol $1), AbsGrusGrus.BFalse (Just (tokenLineCol $1)))
}

Unit :: {
  (Maybe (Int, Int), Unit (Maybe (Int, Int)))
}
: 'Unit' {
  (Just (tokenLineCol $1), AbsGrusGrus.Unit (Just (tokenLineCol $1)))
}

ParserType :: {
  (Maybe (Int, Int), ParserType (Maybe (Int, Int)))
}
: ParserType2 '->' ParserType {
  (fst $1, AbsGrusGrus.PTArrow (fst $1)(snd $1)(snd $3)) 
}
| '(' ParserType ',' ListParserType ')' '->' ParserType {
  (Just (tokenLineCol $1), AbsGrusGrus.PTArrowMult (Just (tokenLineCol $1)) (snd $2)(snd $4)(snd $7)) 
}
| ParserType1 {
  (fst $1, snd $1)
}

ParserType2 :: {
  (Maybe (Int, Int), ParserType (Maybe (Int, Int)))
}
: 'Int' {
  (Just (tokenLineCol $1), AbsGrusGrus.PTInt (Just (tokenLineCol $1)))
}
| 'Bool' {
  (Just (tokenLineCol $1), AbsGrusGrus.PTBool (Just (tokenLineCol $1)))
}
| 'Unit' {
  (Just (tokenLineCol $1), AbsGrusGrus.PTBool (Just (tokenLineCol $1)))
}
| UIdent {
  (fst $1, AbsGrusGrus.PTAlg (fst $1)(snd $1)) 
}
| '(' ParserType ')' {
  (Just (tokenLineCol $1), snd $2)
}

ListParserType :: {
  (Maybe (Int, Int), [ParserType (Maybe (Int, Int))]) 
}
: {
  (Nothing, [])
}
| ParserType {
  (fst $1, (:[]) (snd $1)) 
}
| ParserType ',' ListParserType {
  (fst $1, (:) (snd $1)(snd $3)) 
}

ParserType1 :: {
  (Maybe (Int, Int), ParserType (Maybe (Int, Int)))
}
: ParserType2 {
  (fst $1, snd $1)
}

TypeAlgConstr :: {
  (Maybe (Int, Int), TypeAlgConstr (Maybe (Int, Int)))
}
: UIdent {
  (fst $1, AbsGrusGrus.TAC (fst $1)(snd $1)) 
}
| UIdent '(' ListParserType ')' {
  (fst $1, AbsGrusGrus.TACArgs (fst $1)(snd $1)(snd $3)) 
}

{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    t:_ -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens

pBody = (>>= return . snd) . pBody_internal
}

