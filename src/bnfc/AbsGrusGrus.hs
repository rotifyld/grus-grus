

module AbsGrusGrus where

-- Haskell module generated by the BNF converter




newtype LIdent = LIdent String deriving (Eq, Ord, Show, Read)
newtype UIdent = UIdent String deriving (Eq, Ord, Show, Read)
data Body a = Body a [Decl a] (Exp a)
  deriving (Eq, Ord, Show, Read)

instance Functor Body where
    fmap f x = case x of
        Body a decls expr -> Body (f a) (map (fmap f) decls) (fmap f expr)
data Decl a
    = DPut a (Exp a)
    | DVal a (TypedIdent a) (Exp a)
    | DFun a LIdent [TypedIdent a] (ParserType a) (Body a)
    | DAlg a UIdent [TypeAlgConstr a]
  deriving (Eq, Ord, Show, Read)

instance Functor Decl where
    fmap f x = case x of
        DPut a expr -> DPut (f a) (fmap f expr)
        DVal a typedident expr -> DVal (f a) (fmap f typedident) (fmap f expr)
        DFun a lident typedidents parsertype body -> DFun (f a) lident (map (fmap f) typedidents) (fmap f parsertype) (fmap f body)
        DAlg a uident typealgconstrs -> DAlg (f a) uident (map (fmap f) typealgconstrs)
data TypedIdent a = TypedIdent a LIdent (ParserType a)
  deriving (Eq, Ord, Show, Read)

instance Functor TypedIdent where
    fmap f x = case x of
        TypedIdent a lident parsertype -> TypedIdent (f a) lident (fmap f parsertype)
data Exp a
    = EIfte a (Exp a) (Exp a) (Exp a)
    | ECase a (Exp a) [Case a]
    | EOr a (Exp a) (Exp a)
    | EAnd a (Exp a) (Exp a)
    | EEq a (Exp a) (Exp a)
    | ENeq a (Exp a) (Exp a)
    | ELt a (Exp a) (Exp a)
    | EGt a (Exp a) (Exp a)
    | ELe a (Exp a) (Exp a)
    | EGe a (Exp a) (Exp a)
    | EAdd a (Exp a) (Exp a)
    | ESub a (Exp a) (Exp a)
    | EMult a (Exp a) (Exp a)
    | EDiv a (Exp a) (Exp a)
    | EMod a (Exp a) (Exp a)
    | ECall a (Exp a) [Exp a]
    | ELambda a [TypedIdent a] (Body a)
    | EInt a Integer
    | EBool a (Boolean a)
    | EUnit a (Unit a)
    | EVar a LIdent
    | EAlg a UIdent
  deriving (Eq, Ord, Show, Read)

instance Functor Exp where
    fmap f x = case x of
        EIfte a exp1 exp2 exp3 -> EIfte (f a) (fmap f exp1) (fmap f exp2) (fmap f exp3)
        ECase a expr cases -> ECase (f a) (fmap f expr) (map (fmap f) cases)
        EOr a exp1 exp2 -> EOr (f a) (fmap f exp1) (fmap f exp2)
        EAnd a exp1 exp2 -> EAnd (f a) (fmap f exp1) (fmap f exp2)
        EEq a exp1 exp2 -> EEq (f a) (fmap f exp1) (fmap f exp2)
        ENeq a exp1 exp2 -> ENeq (f a) (fmap f exp1) (fmap f exp2)
        ELt a exp1 exp2 -> ELt (f a) (fmap f exp1) (fmap f exp2)
        EGt a exp1 exp2 -> EGt (f a) (fmap f exp1) (fmap f exp2)
        ELe a exp1 exp2 -> ELe (f a) (fmap f exp1) (fmap f exp2)
        EGe a exp1 exp2 -> EGe (f a) (fmap f exp1) (fmap f exp2)
        EAdd a exp1 exp2 -> EAdd (f a) (fmap f exp1) (fmap f exp2)
        ESub a exp1 exp2 -> ESub (f a) (fmap f exp1) (fmap f exp2)
        EMult a exp1 exp2 -> EMult (f a) (fmap f exp1) (fmap f exp2)
        EDiv a exp1 exp2 -> EDiv (f a) (fmap f exp1) (fmap f exp2)
        EMod a exp1 exp2 -> EMod (f a) (fmap f exp1) (fmap f exp2)
        ECall a expr exps -> ECall (f a) (fmap f expr) (map (fmap f) exps)
        ELambda a typedidents body -> ELambda (f a) (map (fmap f) typedidents) (fmap f body)
        EInt a integer -> EInt (f a) integer
        EBool a boolean -> EBool (f a) (fmap f boolean)
        EUnit a unit -> EUnit (f a) (fmap f unit)
        EVar a lident -> EVar (f a) lident
        EAlg a uident -> EAlg (f a) uident
data Case a = Case a (Exp a) (Exp a)
  deriving (Eq, Ord, Show, Read)

instance Functor Case where
    fmap f x = case x of
        Case a exp1 exp2 -> Case (f a) (fmap f exp1) (fmap f exp2)
data Boolean a = BTrue a | BFalse a
  deriving (Eq, Ord, Show, Read)

instance Functor Boolean where
    fmap f x = case x of
        BTrue a -> BTrue (f a)
        BFalse a -> BFalse (f a)
data Unit a = Unit a
  deriving (Eq, Ord, Show, Read)

instance Functor Unit where
    fmap f x = case x of
        Unit a -> Unit (f a)
data ParserType a
    = PTArrow a (ParserType a) (ParserType a)
    | PTArrowMult a (ParserType a) [ParserType a] (ParserType a)
    | PTInt a
    | PTBool a
    | PTAlg a UIdent
  deriving (Eq, Ord, Show, Read)

instance Functor ParserType where
    fmap f x = case x of
        PTArrow a parsertype1 parsertype2 -> PTArrow (f a) (fmap f parsertype1) (fmap f parsertype2)
        PTArrowMult a parsertype1 parsertypes parsertype2 -> PTArrowMult (f a) (fmap f parsertype1) (map (fmap f) parsertypes) (fmap f parsertype2)
        PTInt a -> PTInt (f a)
        PTBool a -> PTBool (f a)
        PTAlg a uident -> PTAlg (f a) uident
data TypeAlgConstr a
    = TAC a UIdent | TACArgs a UIdent [ParserType a]
  deriving (Eq, Ord, Show, Read)

instance Functor TypeAlgConstr where
    fmap f x = case x of
        TAC a uident -> TAC (f a) uident
        TACArgs a uident parsertypes -> TACArgs (f a) uident (map (fmap f) parsertypes)
